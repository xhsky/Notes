1.操作系统
	IBM公司在1981年推出了个人计算机IBM PC
	
	linux的发展要素
		1.UNIX操作系统
			几乎每个主要的计算机厂商都有其自有版本的UNIX
			通常情况下，比较大型的系统应用，一般都采用固定机型的UNIX解决方案：
				在电信系统以Sun的UNIX系统居多
				在民航以HP的系统居多
				在银行以IBM的系统方案居多
		2.Minix操作系统
			AST保持了Minix的小型化，没有接受各界对Minix扩展的要求
		3.GNU计划
		4.POSIX标准
			是对UNIX操作系统的经验和实践的总结，对操作系统调用的服务器接口进行了标准化，保证所编制的应用程序在源代码一级
			可以在多种操作系统上进行移植。
			linux接口与POSIX相兼容
		5.Internet网络
		
		
	linux和unix的异同
		1.大多数unix操作系统与硬件进行了绑定，而linux可以运行在多种硬件平台上
		2.unix是商业软件(授权大概5万美元)，而linux是免费、开源的
		3.unix除了是操作系统名称外，还是商标，归SCO所有
		4.linux与Unix的System V和BSD UNIX相兼容
		
		
	linux各版本简介
		- Debian 		www.debian.org 			开放的开发模式											apt
		- Ubuntu		www.ubuntu.com			优秀易用的桌面环境，基于Debian构建						apt
		- Fedora		www.redhat.com			庞大的用户，优秀的社区支持，有许多创新					rpm，yum
		- Centos		www.centos.org			RHEL源码编译再分发										rpm，yum
		- SUSE			www.suse.com			专业的操作系统											YaST(rpm)
		- Mandriva		www.mandriva.com		界面友好，使用图形配置，庞大社区支持					rpm
		- KNOPPIX		www.knoppix.com			可以直接在CD上运行，可作为系统的急救盘					apt
		- Gentoo		www.gentoo.org			高度的可定制性，使用手册完整							portage
		
		
	linux内核的主要模块
		1.进程调度				指的是系统对进程的多种状态之间转换的策略
			linux下的进程调度有3种策略
				SCHED_OTHER：	针对普通进程的时间片轮转调度策略
					给所有运行状态的进程分配时间片，当前进程时间片用完之后，调度优先级最高的进程
				SCHED_FIFO：	针对运行的实时性要求比较高，运行时间短的进程调度策略
					按照进入队列的先后进行调度，没有更高优先级进程到来或当前进程不阻塞，会一直运行
				SCHED_RR：		针对运行的实时性要求比较高，运行时间长的进程调度策略
					系统分配SCHED_RR进程时间片，轮循这些进程，将时间片用完的进程放入队列尾部
					
			由于有多种调度策略，linux进程采用的是"有条件剥夺"的调度方式。普通进程采用OTHER，实时进程可剥夺普通进程。
					
		2.内存管理
			linux系统中，内存管理主要是虚拟内存。虚拟内存的分配策略是每个进程都可以公平地使用虚拟内存
		3.虚拟文件系统
			可支持多种文件系统
		4.网络接口
			linux支持多种网络接口和协议。
			网络接口分为网络协议和驱动程序，网络协议是网络传输的通信标准，网络驱动是对硬件设备的驱动程序
		5.进程间通信
			linux支持多进程。进程间通信方式主要有管道、信号、消息队列、共享内存和套接字
			
	GNU通用许可证(GPL)
	GNU宽通用许可证(LGPL)
		一般的GPL分发软件的盈利模式采用服务的方式，发行方法都是将源代码和可执行程序一起放置在互联网上
		
2.linux编程环境
	设置自动缩进		# set cindent shiftwidth=n
	设置tab键			# set tabstop=n
	
	GCC支持默认扩展名策略
		*.c					C源文件
		*.h					C头文件
		*.i					预处理后的C文件
		
		*.C/cc/cxx			C++源文件
		
		*.m					Objective-C原文件
		
		*.s					汇编源文件
		*.o					汇编目标文件
		
		*.a					静态库
		*.so				动态库
		
		a.out				链接后的输出文件
		
	GCC编译器命令
		cc/gcc				C语言编译器
		cpp					预处理编译器
		g++					C++编译器
		
		
	头文件
		/usr/local/include
		/usr/include
		/usr/lib/gcc/*/versin/include
	库文件
	
	GCC对程序的编译
		源文件							  汇编文件  			目标文件		  可执行文件
				预处理	-------->	编译 ------------>	汇编  ------------>	链接
			
			预处理：宏定义，文件包含，条件编译
			编译：	词法分析，语法分析，语义检查和中间码生成，代码优化，生成汇编代码
			汇编：	将汇编语言生成二进制代码
			链接：	
			
			目标文件：	cpu可识别的二进制代码，但一般不能执行(函数过程没有相关的指示和说明)
			可执行文件：将目标文件同相关库链接后的文件
			
		
	库文件
		静态库：	是obj文件的集合，以.a结尾。在程序链接的时候使用，链接器会将程序中使用到的函数代码从库文件中拷贝到应用程序中。一旦链接
					完成，在执行程序的时候就不需要静态库了。 
					由于每个使用静态库的应用程序都需要拷贝所用函数的代码，所以静态链接的文件会比较大
					不用开放源代码而提供库文件，理论上静态库的执行速度比共享库和动态库快(%1-%5)
					
			生成静态库
				# ar -rcs libstr.a string.o
			使用静态库
				# gcc -o test main.c libstr.a [-L /path]	| 		# gcc -o test main.c -lstr [-L /path]
						在默认路径下查找str库或用-L指定路径
		共享库：	是obj文件的集合，是程序启动时加载的库，库中的函数和变量的地址是相对的，其真实地址在调用动态库的程序是加载形成
			动态链接库名称
				别名(soname):				libxxx.so
				真名(realname)				一般在别名的基础上加上一个小版本号，发布版本组成
				链接名(linker name)			程序链接时用到的名字
				
			生成动态链接库
				# gcc -shared -W1,-soname,libxxx.so -o libxx.so.1 xxx.c
					生成动态链接库后直接放到库文件目录下即可
			动态链接库管理
				/etc/ld.so.conf    /etc/ld.so.conf.d/	  /etc/ld.so.cache
				# ldconfig			在系统默认路径(/lib,/usr/lib)和配置文件中所列的目录中搜索动态链接库。
									搜索完成后会写入缓存文件/etc/ld.so.cache
							-v			显示搜索过程
							-p			显示缓存中的动态链接库
							/path		将该目录的动态链接库加入缓存从而被共享
		动态加载库:			可以用程序的方法来控制什么时候加载
			
3.文件系统
4.程序，进程和线程
5.TCP/IP协议族
6.应用层网络服务简介
7.TCP网络编程基础
8.服务器和客户端信息的获取
9.数据的I/O和复用
10.基于UDP协议的接收和发送
11.高级套接字
12.套接字选项
13.原始套接字
14.服务器模型选择
15.IPv6简介
16.linux内核中网络部分结构以及分布
17.netfilter框架内报文处理
